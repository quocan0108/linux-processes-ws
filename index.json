[
{
	"uri": "//localhost:1313/1-introduce-process/",
	"title": "Linux Processes",
	"tags": [],
	"description": "",
	"content": "Processes are a fundamental component of the Linux operating system, representing programs or services that are currently running. Understanding the concept of processes, their various states, and the relationship between parent processes and child processes will help you manage the system more effectively. In this section, we will explore these basic concepts so that you can monitor and control processes in Linux.\nContent: What is a process? Process states Parent and child processes What is a process? In the Linux operating system, a process is a program or service that is being executed. When a program is run, the system initializes a process to carry out the required tasks. Each process has a unique identifier known as the Process ID (PID). The PID allows the operating system and users to identify, manage, and interact with individual processes.\nA process can be a user application such as a web browser or a system service like networking. When a process starts, it is managed by the operating system, including resource allocation (CPU, RAM) and tracking its state throughout its lifecycle.\nProcess states Each process in Linux can be in different states, reflecting its current activity status. The main states are:\nRunning (R):\nThe process is active and being executed by the CPU. A process is in this state when it is either ready to run or currently running on one or more CPUs.\nProcesses in the \u0026ldquo;running\u0026rdquo; state receive CPU processing cycles.\nSleeping (S):\nThe process is inactive but can be woken up when an event occurs.\nThese processes are waiting for specific resources or events (like input/output) to continue execution. A process in this state consumes fewer resources.\nZombie (Z):\nThe process has finished executing but remains in the process table of the system. A zombie process does not perform any tasks but has not been fully removed from the system.\nThis state occurs when the parent process has not received a termination signal from the child process after it completes. The system retains the PID of the zombie process to inform the parent.\nStopped (T):\nThe process is halted and no longer running until it is resumed.\nThis may happen due to user or system intervention (e.g., by sending the SIGSTOP signal). A stopped process can be resumed using the SIGCONT signal.\nParent and child processes Parent Process In Linux, every process has a \u0026ldquo;parent process\u0026rdquo; that created it. The parent process is responsible for initiating and managing its child processes.\nA parent process can spawn multiple child processes by using system calls such as fork() or exec(). When the parent process uses fork(), a copy of itself is created, which becomes the child process.\nThe parent process can monitor and control its child processes, including tracking their status, pausing, resuming, or terminating them.\nThe PID of the parent process can be identified using the ps command or by using pstree to display the entire process tree. Each child process stores the PID of its parent in a field called PPID (Parent Process ID).\nChild Process A child process is a process created by a parent process. It inherits certain attributes from the parent process, such as environment variables, ownership, and other information. After creation, the child process can perform its tasks independently.\nWhen a parent process creates a child process, it can choose to \u0026ldquo;wait\u0026rdquo; for the child process to complete (using wait()), or it can continue running concurrently with the child.\nA child process can also spawn its own child processes, forming a process tree, where processes are organized in a parent-child relationship.\nNotably, the child process has its own unique PID, different from the parent process. However, its PPID will be the PID of the parent process.\n"
},
{
	"uri": "//localhost:1313/",
	"title": "Monitoring and Controlling Processes in Linux",
	"tags": [],
	"description": "",
	"content": "Monitoring and Controlling Processes in Linux Overview In this workshop, we will learn how to monitor and control processes in the Linux operating system, an essential skill for effective system management. Through this, we will be able to control resources, track CPU and RAM usage, and manage processes using basic Linux commands.\nWe will use commands such as ps, pstree and top to view the list of running processes, log system monitoring data for later analysis, and perform operations on processes like moving them to the background, pausing, and resuming them.\nThe hands-on content will include viewing information about the most resource-intensive processes, counting the number of processes based on specific criteria, and managing processes using commands like bg and fg. This workshop will help you understand how to monitor, control and optimize processes in the Linux system.\nMake sure you have a basic understanding of the Linux operating system, as we will be applying this knowledge to monitor and manage processes in the system.\nContents: Introduction to Processes in Linux Process Classification Practice: Monitoring and Controlling Processes in Linux "
},
{
	"uri": "//localhost:1313/2-process-classification/",
	"title": "Linux Process Classification",
	"tags": [],
	"description": "",
	"content": "In the Linux operating system, processes can be classified in various ways based on their roles, origins, and operational states. Understanding process types will help system administrators manage and monitor them more effectively.\nContents System Processes Daemon Processes Managing Processes with init and systemd Foreground and Background Processes System Processes System processes are critical processes used by the operating system to maintain its core functions. They are usually initiated by the OS during startup and handle tasks like hardware management, file systems, and system services.\nExamples:\nkinit, kworker on Linux. systemd or init (in systems using the traditional init) are processes responsible for managing and starting other services. Daemon Processes Daemon processes are background processes that do not require user interaction and typically run continuously to perform background tasks. They usually start at system boot and stop when the system shuts down.\nExamples:\nhttpd (Apache HTTP Server) sshd (OpenSSH Daemon) cron (Task scheduling service) Function: Daemons handle tasks like managing network connections, processing web service requests, and executing scheduled jobs.\nManaging Processes with init and systemd init: The traditional system for booting and managing processes on Unix and Linux systems. init starts during system boot and manages system services based on configuration files such as /etc/inittab.\nAdvantages: Simple, customizable. Disadvantages: No longer widely used in modern operating systems. systemd: A modern system for booting and managing processes used in many modern Linux distributions (such as Ubuntu, Fedora, CentOS). systemd replaces init and provides advanced features like service management, process tracking, and parallelized startup.\nUseful commands:\nsystemctl start \u0026lt;service\u0026gt;: Start a service.\nsystemctl stop \u0026lt;service\u0026gt;: Stop a service.\nsystemctl restart \u0026lt;service\u0026gt;: Restart a service.\nsystemctl status \u0026lt;service\u0026gt;: View the status of a service.\nsystemctl enable \u0026lt;service\u0026gt;: Automatically start a service at system boot.\nsystemctl disable \u0026lt;service\u0026gt;: Disable automatic service startup at system boot.\nForeground and Background Processes Foreground Processes:\nA foreground process is one that the user interacts with directly. When you run a command in the terminal, it typically runs in the foreground.\nManagement: You can pause a foreground process using Ctrl+Z and resume it with the fg command.\nBackground Processes:\nA background process is one that doesn\u0026rsquo;t require user interaction and does not take control of the terminal. This allows you to keep working in the terminal while the process continues to run.\nHow to run:\nTo run a command in the background, add an \u0026amp; at the end of the command. For example: long-running-command \u0026amp; Management:\nList background processes: Use the jobs command to view the list of background processes.\nResume a background process: Use the bg %\u0026lt;job_number\u0026gt; command to resume a paused background process.\nBring a background process to the foreground: Use fg %\u0026lt;job_number\u0026gt; to bring it to the foreground.\n"
},
{
	"uri": "//localhost:1313/3-control-monitoring/",
	"title": "Monitoring and Controlling Processes",
	"tags": [],
	"description": "",
	"content": "After understanding the concepts and classification of processes, this practical section will provide specific tools to help you monitor and manage processes in a Linux system. The provided commands will allow you to monitor active processes in detail, control system resources, and handle abnormal processes. Through these exercises, you will gain practical insights into process management, thereby enhancing your system administration skills.\nContents View a list of running processes View a list of processes in tree format View a list of processes with the top command Save the top command output to the file /root/top.txt Check CPU and RAM usage for each process Print information about the process using the most CPU Count the number of running processes on the system Count the number of processes for the root user Count the number of httpd processes for the root user List all files and directories and save the output to list.txt Move the above listing command to the background Resume a suspended command View a list of running processes Command: ps Description: This command lists all running processes, including process ID (PID), process owner, and other details such as start time and state. View a list of processes in tree format Command: pstree Description: This command displays processes in a tree format, making it easier to observe relationships between processes (e.g., parent and child processes). View a list of processes with the top command Command: top Description: Displays running processes in real-time along with information about CPU and memory usage, uptime and more. You can see which processes are consuming the most resources. Save the top command output to the file /root/top.txt Command: top -n 1 -b \u0026gt;top.txt and head top.txt to check the contents of the file. Description: Lists all files and directories in detailed, recursive format (including subdirectories), saving the result to a file. Check CPU and RAM usage for each process Command: ps -eo pid,ppid,cmd,%mem,%cpu Description: Displays information about PID, parent process (PPID), executed command, and the percentage of memory and CPU used by each process. Print information about the process using the most CPU Command: ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%cpu | head -n 2 Description: This command sorts processes by CPU usage and prints the process that is using the most CPU. Count the number of running processes on the system Command: ps | wc -l Description: Uses the wc command to count the number of lines in the output of ps, indicating how many processes are currently running. Count the number of processes for the root user Command: ps -U root | wc -l Description: This command counts the number of processes being run by the root user. Count the number of httpd processes for the root user Command: ps -U root | grep httpd | wc -l Description: Finds processes related to httpd run by the root user and counts the number of them. List all files and directories and save the output to list.txt Command: ls -lR \u0026gt; list.txt and head list.txt to check the contents of the file. Description: Lists all files and directories in detailed, recursive format (including subdirectories), saving the result to a file. Move the above listing command to the background Command: bg Description: Moves a suspended command to the background to continue running without waiting for it to finish. Resume a suspended command Command: fg Description: Resumes a suspended command with fg, bringing it back to the foreground. "
},
{
	"uri": "//localhost:1313/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]